# Item11 : equals를 재정의하려거든 hashCode도 재정의하라
 
## Why?
> eqauls(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.

- eqauls를 재정의 하는 것은 두 인스턴스를 같은 객체로 판단하도록 재정의 하는 것이다.  
-  위 Object 명세를 지키기 위해서는 같은 객체는 같은 해시코드를 반환해야 한다.
- 하지만 Object의 기본 hashCode는 eqauls를 재정의 한 경우 두 객체를 전혀 다르다고 판단한다.

~~~~

Map<PhoneNubmer, String> m = new HashMap<>();
m.put(new PhoneNumber(707, 867, 5309), "제니");
m.get(new PhoneNumber(707,867, 5309))

~~~~
위 코드의 결과로는 "제니"가 나와야 할 것 같지만 실제로는 null을 반환한다.
논리적 동치인 두 인스턴스에 대해서 서로다른 해시코드를 반환하는 것이다.
이런 Case를 방지하고 Object 명세를 지키기 위해서 __hashCode를 재정의해주어야 한다.__

## 올바른 hashCode란?
### 최악의 코드
~~~~
@Overrid
public int hashCode(){ return 42 }
~~~~
- 위 코드는 동치인 모든 객체에서 똑같은 해시코드를 반환하니 적법하다.
- 하지만 평균 수행시간이 O(1)에서 O(n)으로 느려져서, 객체가 많아지면 도저히 쓸 수 없게 된다.
- 좋은 해시 함수라면 서로 다른 인스턴스에 다른 해시코드를 반환한다.

### hashCode를 작성하는 간단한 요령

>**ㄱ. 핵심 필드를 ㄴ.a 방법으로 계산한다**
>
>int result; 를 선언한 후 값 c로 초기화하는데, 이때  c는 핵심필드를 계산한 값>이다.
>
>**ㄴ. 객체의 나머지 핵심 필드에 대해 계산을 수행한다.**
>
>a. 해당 필드의 해시 코드를 계산한다.
>
>-   기본 타입 필드 : Type.hashCode(f) = Integer.hashCode(f);
>-   참조 타입 필드 + equals가 재귀적으로 호출 : hascode도 재귀적 호출  
 >   복잡할 것 같으면 표준형(canoical representation)을 만들어 그 표준형의 >hashCode를 호출한다.
>-   필드가 배열이면, 핵심원소 각가을 별도 필드처럼 다룬다. (Arrays.hashCode)
>
>b. ㄴ.a에서 계산한 해시코드로 갱신한다 : result = 31 * result + c
>
>**ㄷ. result를 반환한다.**
>

### hashCode를 구현한 모듈
-   Objects.hash()
    -  내부적으로 AutoBoxing이 일어나 성능이 떨어진다.
-   Lombok의 @EqualsAndHashCode
-   Google의 @AutoValue

## hashCode를 재정의할 때 주의해야 할 점

-  클래스가 불변이고 해시코드를 계산하는 비용이 크다면, 매번 새로 계산하기 보다는 캐싱하는 방식을 고려하자
   - 단 쓰레드 안전성을 고려해야한다.
- 성능을 높인답시고 hashcode를 계산할 떄 핵심필드를 생략해서는 안된다.
- hashCode가 반환하는 값의 생성규칙을 API사용자에게 자세히 공표하지 말자
    -   클라이언트가 hashcode값에 의지한 코드를 짜지 않고 추후에 바꿀 수도 있다.
    -   다음 릴리즈 시, 성능을 개선할 여지가 있다.


# Item14 : `Comparable`을 구현할지 고려하라
`compareTo` 는 `Comparable` 인터페이스에 유일하게 존재하는 method 이다.

```java
public interface Comparable<T> {
    /**
     * Compares this object with the specified object for order.  Returns a
     * negative integer, zero, or a positive integer as this object is less
     * than, equal to, or greater than the specified object.
	   ... 
     * @param   o the object to be compared.
     * @return  a negative integer, zero, or a positive integer as this object
     *          is less than, equal to, or greater than the specified object.
     *
     * @throws NullPointerException if the specified object is null
     * @throws ClassCastException if the specified object's type prevents it
     *         from being compared to this object.
     */
    public int compareTo(T o);
}
```

> `Compares this object with the specified object for order.`
> 
>
> `throws ClassCastException if the specified object's type prevents it from being compared to this object.`
> 

모든 객체에 대해 전역 동치관계를 부여하는 `equals`와 달리 `compareTo` 메소드는 타입이 다른 객체를 신경 쓰지 않아도 된다. 타입이 다른 객체가 주어지면 간단히 `ClassCastException`을 던져도 되며 대부분 그렇게 사용한다. 물론 다른 타입 사이 비교도 허용한다.

```java
public final class Integer extends Number implements Comparable<Integer> {
    /**
     * A constant holding the minimum value an {@code int} can
     * have, -2<sup>31</sup>.
     */
    @Native public static final int   MIN_VALUE = 0x80000000;
		...
```

`String`, `Integer` 와 같이 값을 값는 모든 객체와 `Enum` 타입은 `Comparable`을 구현한 객체이다.

```java
@Test
void compareTo_음수가_나온다() {
    Integer a = 1;
    Integer b = 2;
		assertThat(a.compareTo(b)).isNegative();
		assertThat(a.compareTo(b)).isEqualTo(-1);
}

@Test
void compareTo_양수가_나온다() {
    Integer a = 2;
    Integer b = 1;
		assertThat(a.compareTo(b)).isPositive();
		assertThat(a.compareTo(b)).isEqualTo(1);
}
```

>`sgn`은 표현식이며 부호 함수를 의미 (음수, 양수, 0)
>
> `Comparable`을 구현한 클래스는 모든 x, y에 대해 `sgn(x.compareTo(y)) == -sgn(y.compareTo(x))`이어야 한다.
>
>`Comparable`을 구현한 클래스는 모든 z에 대해 `x.compareTo(y) == 0` 이면 `sgn(x.compareTo(z)) == sgn(y.compareTo(z))`다.
>
>`Comparable`을 구현한 클래스는 추이성을 보장한다.
>`x.compareTo(y) > 0 && y.compareTo(z) > 0`가 성립하면 `x.compareTo(z) > 0`도 성립한다.
>
>(권고사항) `(x.compareTo(y)) == 0 == (x.equals(y))` 이 코드를 지키지 못하면 명시해야 한다.
> 

- (참고) `String str = “”, new String(””)` 차이?
    
    • new String()은 새로운 객체를 만드는 것으로 `heap area`에 저장이 되고, String str = ""; 처럼 리터럴을 이용한 변수 할당은,`string constant pool`영역에 저장되기 때문에 서로 잠조하고 있는 레퍼런스 주소가 다르다.
    
    • 리터럴로 스트링을 생성한다면, 내부적으로 `intern()`이라는 메소드가 실행되면서, `string constant pool`를 한번 훑고 기존에 존재하는 string값이 있으면, 그 값의 레퍼런스 주소를 할당받고, 없으면 새로 생성한 뒤 그 주소를 받도록 한다.
    
    ```java
    
    @Test
        public void testNewInstanceFirst() {
            System.out.println("testNewInstanceFirst");
            // new
            String a = new String("ssafy");
            String b = new String("ssafy");
            int a_addr = System.identityHashCode(a);
            int b_addr = System.identityHashCode(b);
            System.out.println("a : " + a_addr);
            System.out.println("b : " + b_addr);
            System.out.println();
            assertNotEquals(a_addr, b_addr);
            // leteral
            String c = "ssafy";
            String d = "ssafy";
            int c_addr = System.identityHashCode(c);
            int d_addr = System.identityHashCode(d);
            System.out.println("c : " + c_addr);
            System.out.println("d : " + d_addr);
            System.out.println();
            assertEquals(c_addr, d_addr);
            // intern
            String e = b.intern();
            System.out.println("e : " + System.identityHashCode(e));
        }
    ```
    
    ![Untitled](./intern.png)
    

### `compareTo`는 동치인지 비교하는게 아니라 그 순서를 비교한다.

만약 객체 참조의 필드를 비교하고자 한다면 재귀적으로 `compareTo` 를 호출해야 한다. 만약 `Comparable` 을 구현하지 않았다면 `Comparator` 를 사용한다. 

```java
class PhoneNumber {
	public int compareTo(PhoneNumber pn) {
		int result = Short.comparable(areaCode, pn.areaCode); // 가장 먼저 비교할 필드
		if (result == 0) {
			result = Short.compare(prefix, pn.prefix); // 두번째로 비교할 필드
			if (result == 0) {
				result = Short.compare(lineNum, pn.lineNum); // 세번째로 비교할 필드
			}
		}
		return result;
	}
}
```

> 일단, 두 인터페이스를 구체적으로 알아보기에 앞서 먼저 정답부터 말하자면, Comparable은 **"자기 자신과 매개변수 객체를 비교"**하는 것이고, Comparator는 **"두 매개변수 객체를 비교"**한다는 것이다.
>
>쉽게 말하자면, Comparable은 자기 자신과 파라미터로 들어오는 객체를 비교하는 것이고, Comparator는 자기 자신의 상태가 어떻던 상관없이 파라미터로 들어오는 두 객체를 비교하는 것이다. 즉, **본질적으로 비교한다는 것 자체는 같지만, 비교 대상이 다르다는 것**이다.
>
>또 다른 차이점이라면 Comparable은 lang패키지에 있기 때문에 import 를 해줄 필요가 없지만, Comparator는 util패키지에 있다.
>
>**둘다 반드시 overriding 해줘야 한다.**
>
>[https://st-lab.tistory.com/243](https://st-lab.tistory.com/243)
> 

```java
class PhoneNumber {
	private static final Comparator<PhoneNumber> COMPARATOR =
		comparingInt((PhoneNumber pn) -> pn.areaCode)
			.thenComparingInt(pn -> pn.prefix)
			.thenComparingInt(pn -> pn.lineNum);

	public int compareTo(PhoneNumber pn) {
		return COMPARATOR.compare(this, pn);
	}
}
```

Java 의 type 추론 능력이 뛰어나지 않기 때문에 (`PhoneNumber pn`) 와 같이 명시할 필요가 있다.
첫 번째 비교인 `comparingInt` 가 진행되고 다음 비교 인자를 비교하기 위해 `thenComparingInt` 를 사용하여 그 다음 변수를 비교하고, 한번 더 그 다음 변수를 비교한다.

그런데 두개의 매개변수를 받아 정렬을 해야 하는 경우가 있다.

```java
Arrays.sort(people, new Comparator<int[]>() {
    @Override
    public int compare(int[] o1, int[] o2) {
      return o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0];
    }
});
```

```java
Arrays.sort(people, (o1, o2) -> o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]);
```

`o1`, `o2` 에 대한 범위가 명시되어 있으니 문제가 없지만 만약 값이 int 범위를 넘거나 매개변수가 `int`가 아닌 소수점이 들어온다면?

**즉, 정수 overflow를 일으키거나, IEEE754 부동 소수점 계산에 따른 오류가 발생할 수 있다.**

```java
Arrays.sort(people, (o1, o2) -> Objects.equals(o1[0], o2[0]) ?
        Integer.compare(o1[1], o2[1]): Integer.compare(o2[0], o1[0]);
```

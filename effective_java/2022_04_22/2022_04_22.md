# Item11 : equals를 재정의하려거든 hashCode도 재정의하라
 
## Why?
> eqauls(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.

- eqauls를 재정의 하는 것은 두 인스턴스를 같은 객체로 판단하도록 재정의 하는 것이다.  
-  위 Object 명세를 지키기 위해서는 같은 객체는 같은 해시코드를 반환해야 한다.
- 하지만 Object의 기본 hashCode는 eqauls를 재정의 한 경우 두 객체를 전혀 다르다고 판단한다.

~~~~

Map<PhoneNubmer, String> m = new HashMap<>();
m.put(new PhoneNumber(707, 867, 5309), "제니");
m.get(new PhoneNumber(707,867, 5309))

~~~~
위 코드의 결과로는 "제니"가 나와야 할 것 같지만 실제로는 null을 반환한다.
논리적 동치인 두 인스턴스에 대해서 서로다른 해시코드를 반환하는 것이다.
이런 Case를 방지하고 Object 명세를 지키기 위해서 __hashCode를 재정의해주어야 한다.__

## 올바른 hashCode란?
### 최악의 코드
~~~~
@Overrid
public int hashCode(){ return 42 }
~~~~
- 위 코드는 동치인 모든 객체에서 똑같은 해시코드를 반환하니 적법하다.
- 하지만 평균 수행시간이 O(1)에서 O(n)으로 느려져서, 객체가 많아지면 도저히 쓸 수 없게 된다.
- 좋은 해시 함수라면 서로 다른 인스턴스에 다른 해시코드를 반환한다.

### hashCode를 작성하는 간단한 요령

>**ㄱ. 핵심 필드를 ㄴ.a 방법으로 계산한다**
>
>int result; 를 선언한 후 값 c로 초기화하는데, 이때  c는 핵심필드를 계산한 값>이다.
>
>**ㄴ. 객체의 나머지 핵심 필드에 대해 계산을 수행한다.**
>
>a. 해당 필드의 해시 코드를 계산한다.
>
>-   기본 타입 필드 : Type.hashCode(f) = Integer.hashCode(f);
>-   참조 타입 필드 + equals가 재귀적으로 호출 : hascode도 재귀적 호출  
 >   복잡할 것 같으면 표준형(canoical representation)을 만들어 그 표준형의 >hashCode를 호출한다.
>-   필드가 배열이면, 핵심원소 각가을 별도 필드처럼 다룬다. (Arrays.hashCode)
>
>b. ㄴ.a에서 계산한 해시코드로 갱신한다 : result = 31 * result + c
>
>**ㄷ. result를 반환한다.**
>

### hashCode를 구현한 모듈
-   Objects.hash()
    -  내부적으로 AutoBoxing이 일어나 성능이 떨어진다.
-   Lombok의 @EqualsAndHashCode
-   Google의 @AutoValue

## hashCode를 재정의할 때 주의해야 할 점

-  클래스가 불변이고 해시코드를 계산하는 비용이 크다면, 매번 새로 계산하기 보다는 캐싱하는 방식을 고려하자
   - 단 쓰레드 안전성을 고려해야한다.
- 성능을 높인답시고 hashcode를 계산할 떄 핵심필드를 생략해서는 안된다.
- hashCode가 반환하는 값의 생성규칙을 API사용자에게 자세히 공표하지 말자
    -   클라이언트가 hashcode값에 의지한 코드를 짜지 않고 추후에 바꿀 수도 있다.
    -   다음 릴리즈 시, 성능을 개선할 여지가 있다.


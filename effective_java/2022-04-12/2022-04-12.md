# 1주차 : item 1 ~ 10
## 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라


## 아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라


## 아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라


## 아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라


## 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라


## 아이템 6. 불필요한 객체 생성을 피하라


## 아이템 7. 다 쓴 객체 참조를 해제하라

# 1) 자바는 가비지 컬렉터를 가지고 있어 프로그래머의 삶을 평안하게 했다.
  - C, C++처럼 메모리를 직접 관리 [ex) malloc, free] 를 하다 자바를 사용하면 편리
  - But 메모리 관리에 신경 써야 한다!!, 자바의 가비지 컬렉터는 완벽하지 않다.


![image](https://user-images.githubusercontent.com/91466962/162967147-12006212-3944-4c7e-9116-4bd324cd4d32.png)

# 2) 메모리 누수
  - 위 클래스는 메모리 누수를 발생 시킨다.
  - 가비지 컬렉션 활동을 증가시키고, 메모리 사용량이 증가하여 성능을 저하시킨다.
  - 심한경우 디스크 페이징, OutOfMemoryError를 일으킨다.

# 3) Obsolete reference (다 쓴 참조)
  - 스택이 커졌다가 줄어들었을 때 스택에서 꺼내진 객체들은 가비지 컬렉터가 회수하지 않는다.
  - 스택이 객체들의 다 쓴 참조를 가지고 있기 때문이다.
  - '활성영역' 밖의 참조들이 모두 여기에 해당된다.


![image](https://user-images.githubusercontent.com/91466962/162968617-58bc7e9e-3732-41b1-9292-168c91d48807.png)

# 4) 객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.
  - 다 쓴 참조를 해제하는 가장 좋은 방법은 그참조를 담은 변수를 유효 범위(scope)밖으로 밀어내는 것이다.(아이템 57)

# 5) Stack은 왜 null 처리를 하였는가?
  - 스택은 메모리를 자기가 관리하기 떄문이다.
  - elements 배열로 저장소 풀을 만들어 원소들을 관리하였기 떄문에 가비지 컬렉터가 비활성 영역을 알수가 없다.

# 6) 메모리 누수의 주범들 (캐시, 리스너, 콜백)
  - 객체 참조를 캐시에 넣고 잊어버리면 메모리 누수의 원인이 된다.
  - 키를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요한 상황이라면 WeakHashMap을 사용해 캐시를 만들자.
  - 캐시 엔트리의 유효기간을 정의하기 어렵다면 '백그라운드 스레드를 활용'하거나 'removeEldestEntry'를 활용해 처리
  - 콜백을 등록하고 명확히 해지하지 않으면 콜백이 쌓여 메모리 누수 발생
  - weakHashMap을 통해 약한 참조를 만들자. 

## 아이템 8. finalizer와 cleaner 사용을 피하라


## 아이템 9. try-finally보다는 try-with-resources를 사용하라


## 아이템 10. equals는 일반 규약을 지켜 재정의하라

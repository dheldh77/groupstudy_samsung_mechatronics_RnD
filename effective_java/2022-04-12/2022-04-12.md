# 1주차 : item 1 ~ 10
## 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라


## 아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라


## 아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라


## 아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라


## 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라


## 아이템 6. 불필요한 객체 생성을 피하라


## 아이템 7. 다 쓴 객체 참조를 해제하라

### 1) 자바는 가비지 컬렉터를 가지고 있어 프로그래머의 삶을 평안하게 했다.
  - C, C++처럼 메모리를 직접 관리 [ex) malloc, free] 를 하다 자바를 사용하면 편리
  - But 메모리 관리에 신경 써야 한다!!, 자바의 가비지 컬렉터는 완벽하지 않다.


![image](https://user-images.githubusercontent.com/91466962/162967147-12006212-3944-4c7e-9116-4bd324cd4d32.png)

### 2) 메모리 누수
  - 위 클래스는 메모리 누수를 발생 시킨다.
  - 가비지 컬렉션 활동을 증가시키고, 메모리 사용량이 증가하여 성능을 저하시킨다.
  - 심한경우 디스크 페이징, OutOfMemoryError를 일으킨다.

### 3) Obsolete reference (다 쓴 참조)
  - 스택이 커졌다가 줄어들었을 때 스택에서 꺼내진 객체들은 가비지 컬렉터가 회수하지 않는다.
  - 스택이 객체들의 다 쓴 참조를 가지고 있기 때문이다.
  - '활성영역' 밖의 참조들이 모두 여기에 해당된다.


![image](https://user-images.githubusercontent.com/91466962/162968617-58bc7e9e-3732-41b1-9292-168c91d48807.png)

### 4) 객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.
  - 다 쓴 참조를 해제하는 가장 좋은 방법은 그참조를 담은 변수를 유효 범위(scope)밖으로 밀어내는 것이다.(아이템 57)

### 5) Stack은 왜 null 처리를 하였는가?
  - 스택은 메모리를 자기가 관리하기 떄문이다.
  - elements 배열로 저장소 풀을 만들어 원소들을 관리하였기 떄문에 가비지 컬렉터가 비활성 영역을 알수가 없다.

### 6) 메모리 누수의 주범들 (캐시, 리스너, 콜백)
  - 객체 참조를 캐시에 넣고 잊어버리면 메모리 누수의 원인이 된다.
  - 키를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요한 상황이라면 WeakHashMap을 사용해 캐시를 만들자.
  - 캐시 엔트리의 유효기간을 정의하기 어렵다면 '백그라운드 스레드를 활용'하거나 'removeEldestEntry'를 활용해 처리
  - 콜백을 등록하고 명확히 해지하지 않으면 콜백이 쌓여 메모리 누수 발생
  - weakHashMap을 통해 약한 참조를 만들자. 

## 아이템 8. finalizer와 cleaner 사용을 피하라

### 1) 자바는 두가지 객체 소멸자를 제공한다. -> 'finalizer' 와 'cleaner'
  - 'finalizer'는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다.
  - 쓰임새가 있지만 자바9 에서는 사용 자제(deprecated) API로 지정, cleaner를 대안으로 소개
  - But cleaner는 finalizer보다는 덜위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요

### 2) 'finalizer' 와 'cleaner'로는 제 떄 실행되어야 하는 작업은 절대 할 수 없다.
  - 즉시 수행된다는 보장이 없다.
  - 가비지 컬렉터 알고리즘에 따라 수행시점이 천차 만별 -> 고객의 시스템에서 문제를 일으킬 수 있다.

### 3) 현업에서의 finalizer 가 일으킨 문제
  - 클래스에 finalizer를 달아 인스턴스의 자원 회수가 지연
  - 그래픽스 객체 수천개가 finalizer 대기열에서 회수되기만을 기다리다가 스레드 우선순위가 밀려 실행 X
  - OutOfMemoryError를 내며 GUI App 다운
  - 그나마 'cleaner'는 스레드를 제어할 수 있다. 하지만 여전히 백그라운드에서 수행

### 4) 상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존해서는 안 된다.
  - 예를들어 데이터베이스 같은 공유 자원의 영구 락(lock)해제를 finalizer나 cleaner에 맡겨놓으면 분산 시스템 전체가 멈출것이다.

### 5) finalizer와 cleaner의 추가적인 문제들
  - finalizer 동작 중 발생한 예외는 무시되며, 처리할 작업이 남았더라도 그순간 종료된다.
  - 심각한 성능 문제도 동반한다. 객체를 생성하고 가비지 컬렉터가 수거하는것에 비해서 과도하게 시간이 오래걸린다.
  - finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수 있다.

### 6) 파일이나 스레드 등 종료해야 할 자원을 담고 있는 객체의 클래스는 어떻게 해야할까?
  - AutoCloseable을 구현하고 인스턴스를 다쓴 경우 close 메소드를 호출한다.
  - 예외가 발생해도 종료가 되도록 try - with - resource를 사용해야 한다.

### 7) 그러면 finalizer와 cleaner는 언제 사용되는가??
  - 첫번째로는 close 메서드를 호출하지 않는 것에 대비한 안전망 역할이다. 늦게나마 자원 회수가 되는것이 안하는것보다 낫다.
  - 두 번째 예는 native peer와 연결된 객체에서다. native peer는 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말한다.
  - native peer는 자바 객체가 아니여서 가비지 컬렉터가 인식하지 못한다.
 
### 8) cleaner 사용하기

![image](https://user-images.githubusercontent.com/91466962/162985390-db596331-8045-4e23-b963-c474447cfa00.png)

  - 이 예에서 numJunkPiles 필드가 수거할 자원에 해당한다.
  - run 메서드가 호출되는 경우는 둘중 하나다. 보통 Room의 close 메서드를 호출할 때이다.
  - 두번째 경우는 가비지 컬렉터가 Room을 회수할 떄 cleaner가 State의 run 메서드를 호출해줄 것이다.
  - 모든 Room 생성을 try-with resource 블록으로 감쌋다면 자동 청소는 전혀 필요하지 않다.

![image](https://user-images.githubusercontent.com/91466962/162988112-0d521dd6-caf8-4124-bde8-e6ff4a176d2b.png)



### Summary 
  - 'Finalizer'는 절대적으로 지양하고 'Cleaner'의 경우도 불확실성과 성능 이슈가 있으니 안전망이나 중요하지 않은 자원 회수용으로 사용하자.

## 아이템 9. try-finally보다는 try-with-resources를 사용하라


## 아이템 10. equals는 일반 규약을 지켜 재정의하라

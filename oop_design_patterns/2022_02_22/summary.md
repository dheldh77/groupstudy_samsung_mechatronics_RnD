# 04 재사용 : 상속보단 조립
## 1) 상속과 재사용
- 상속은 기능을 확장할 수 있기 때문에 기능의 재사용이라는 장점이 있지만, 변경의 유연함이라는 측면에서 치명적인 단점을 가짐
<br/>

> 상속을 통한 재사용의 단점 
>> 상위 클래스 변경의 어려움
>> - 어떤 클래스를 상속받는 다는 것은 그 클래스를 의존하는 것.
>> - 의존하는 클래스의 코드가 변경되면 영향을 받을수 있음
>> - 상속 계층을 따라 상위 클래스의 변경이 하위 클래스에 영향을 준다.
>> 
>> 클래스의 불필요한 증가
>> - 필요한 기능의 조합이 증가할수록 클래스의 개수는 함께 증가하고 구조가 복잡해진다.
>> 
>> 상속의 오용
>> - 상속은 IS-A 관계가 성립할 때에만 사용해야 한다.
>> - 서로 다른 책임을 갖고 있는 클래스의 구현을 재사용하기 위해 상속을 받게 되면 잘못된 사용으로 인한 문제점이 발생한다.
>> <br/>

## 2) 조립을 이용한 재사용
- 객체 조립(Composition)은 여러 객체를 묶어서 더 복잡한 기능을 제공하는 객체를 만들어 내는 것
- 객체 지향 언어에서 객체 조립은 보통 필드에서 다른 객체를 참조하는 방식으로 구현
- 한 객체가 다른 객체를 조립해서 필드로 갖는다는 것은 다른 객체의 기능을 사용한다는 의미를 내포
- 조립을 사용하면 상속을 잘못 사용해서 발생했던 문제가 제거(상위 클래스 변경의 어려움, 클래스의 불필요한 증가, 상속의 오용)
- 또한 조립은 런타임에 조립 대상 객체를 교체할 수 있음
<br/>

> 상속보다는 객체 조립을 사용할 것
- 상속을 사용하다 보면 변경의 관점에서 유연함이 떨어질 가능성이 높기 때문에 객체 조립을 먼저 고민할 것
- 단, 조립의 단점은 런타임 구조가 복잡해지고 구현이 어렵다는 것
<br/>

## 3) 위임(Delegation)
- 책임을 다른 객체에 넘긴다는 의미로 조립 방식을 이용해 위임을 구현
- 위임은 조립과 마찬가지로 요청을 위임할 객체를 필드로 연결
- 또는 메소드 안에서 객체를 새로 생성해서 요청을 전달해도 위임이란 의미에서 벗어나지 않음
<br/>

## 4) 상속을 사용해야할 때
- 재사용이라는 관점이 아닌 기능의 확장이라는 관점에 적용
- 명확한 IS-A 관계가 성립할 때 점진적으로 상위 클래스의 기능을 확장해나가기위해 적용
<br/><br/><br/><br/><br/>



# 05. 설계원칙 : SOLID
- 단일 책임 원칙 (SRP, Single responsibility principle)
- 개방-폐쇄 원칙 (OCP, Open-closed principle)
- 리스코프 치환 원칙 (LSP, Liskov substitution principle)
- 인터페이스 분리 원칙 (ISP, Interface segregation principle)
- 의존 역전 원칙 (DIP, Dependency inversion principle)
<br/>

## 1) 단일 책임 원칙 (SRP, Single responsibility principle)
- "클래스는 단 하나의 책임을 가져야한다"
- 객체 지향의 기본은 책임을 객체에게 할당하는 것
- 책임마다 변경되는 이유가 발생하기 때문
- 클래스가 한 개의 이유로만 변경되려면 클래스는 한 개의 책임만을 가져야 함
- 즉, 클래스를 변경하는 이유는 단 하나여야 한다.
<br/>

> 단일 책임 원칙을 위반 시 발생하는 문제점
- 하나의 기능의 변화로 연쇄적인 변화가 발생
- 재사용을 어렵게 만듬
- 여러가지 책임이 있을 경우, 하나의 책임을 재사용하기 위해 실제 필요하지 않는 책임까지 필요
<br/>

> 책임이란 변화에 대한 것
- 책임의 단위는 변화되는 부분과 관련
서로 다른 이유로 바뀌는 책임들이 한 클래스에 함께 포함되어 있다면 해당 클래스는 단일 책임을 어기고 있는 것
<br/>

## 2) 개방 폐쇄 원칙 (OCP, Open-closed principle)
- "확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다"
- 즉, 기능을 변경하거나 확장할 수 있으면서 그 기능을 사용하는 코드는 수정하지 않는다는 의미
- 개방 폐쇄 원칙을 구현할 수 있는 이유는 확장되는 부분(즉, 변화되는 부분)을 '추상화'해서 표현했기 때문 -> 추상화로 구현 가능
- 개방 폐쇄 원칙을 구현하는 또 다른 방법은 상속을 이용
<br/>

> 개발 폐쇄 원칙이 깨질 때의 주요 증상
- '추상화'와 '다형성'을 이용해서 개방 폐쇄 원칙을 구현하기 때문에, '추상화'와 '다형성'이 제대로 지켜지지 않은 코드는 개방 폐쇄 원칙을 어기게 됨
- '다운 캐스팅을 하게 된다.'
- '비슷한 if-else block이 존재한다.'
<br/>

> 개방 폐쇄 원칙은 유연함에 대한 것
- 개방 폐쇄 원칙은 변경의 유연함과 관련
- 개방 폐쇄 원칙은 변화되는 부분을 추상화함으로써 사용자 코드 입장에서 변화를 고정
- 변화가 예상되는 것을 추상화해서 변경의 유연함을 제공
<br/>

## 3. 리스코프 치환 원칙(Liskove substitution principle)
- "상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야한다."
- 리스코프 치환 원칙은 개방 폐쇄 원칙을 받쳐 주는 다형성에 관한 원칙을 제공
- 리스코프 치환 원칙이 제대로 지켜지지 않으면 다형성에 기반한 개방 폐쇄 원칙이 지켜지지 않음
<br/>

> 리스코프 치환 원칙을 지키지 않을 때의 문제점
- [직사각형-정사각형 문제](https://codingdog.tistory.com/entry/%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95-%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95-%EB%AC%B8%EC%A0%9C-A-is-a-B-%EA%B4%80%EA%B3%84%EC%9D%B8%EB%8D%B0-%EC%83%81%EC%86%8D%EC%9D%84-%EC%93%B0%EA%B8%B0%EC%97%90%EB%8A%94)
- 개념적으로 상속 관계에 있는 것처럼 보일지라도 실제 구현에서는 상속 관계가 아닐 수도 있음
- 추가 예로 상위 타입에서 지정한 리턴 값의 범위에 해당되지 않는 값을 리턴하는 것
<br/>

> 리스코프 치환 원칙은 계약과 확장에 대한 것
- 명시된 명세에서 벗어난 값 리턴, 명시된 명세에서 벗어난 익셉션 발생, 명시된 명세에서 벗어난 기능 수행 등의 위반 사례가 있음
-  하위 타입은 상위 타입에서 정의한 명세를 벗어나지 않는 범위에서 구현
<br/>

> 리스코프 치환 원칙은 확장에 대한 것
- 타입을 확인하는 기능을 사용하는 것은 전형적인 리스코프 치환 원칙을 위반할 때 발생하는 증상으로 상위 타입에 대한 추상화가 덜 되었기 때문
- 이는 상위 타입만으로 개발할 수 없다는 뜻이며 하위 타입이 상위 타입을 대체할 수 없고 확장이 어렵게 됨
- 새로운 하위 타입이 생길 때마다 상위 타입을 사용하는 코드를 수정 -> 개방 폐쇄 원칙 위반
- 변화되는 부분을 추상화를 통해 상위 타입에 추가함으로써 리스코프 치환 원칙을 지킬 수 있음

<br/>

## 4. 인터페이스 분리 원칙 (ISP, Interface segregation principle)
- "인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리"
- "클라이언트는 자신이 사용하는 메서드만 의존해야 함"
<br/>

> 인터페이스 분리 원칙을 지키지 않을 때의 문제점
- 인터페이스의 한 멤버 함수에 대한 시그니처의 변경이 발생할 경우 해당 인터페이스를 사용하는 모든 클래스를 변경해야하거나 재컴파일해야 함
- 인터페이스를 각 클라이언트가 필요로 하는 인터페이스들로 분리함으로써, 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향이 받지 않도록 만들어야 함
- 또한 용도에 맞게 인터페이스를 분리하는 것으로 변경에 대한 여파를 최소화(단일 책임 원칙)
<br/>

> 인터페이스 분리 원칙은 클라이언트에 대한 것
- 각 클라이언트가 사용하는 기능을 중심으로 인터페이스를 분리함으로써, 하나의 클라이언트로부터 발생하는 인터페이스 변경의 연파가 다른 클라이언트에 미치는 영향을 최소화
<br/>

## 5. 의존 역전 원칙(DIP, Dependency inversion principle)
- "고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다."
<br/>

> 고수준 모듈과 저수준모듈이란?
- 고수준 모듈 : 어떤 의미 있는 단일 기능을 제공
- 저수준 모듈 : 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현
<br/>

> 의존 역전 원칙을 지키지 않을 때의 문제점
- 요구사항이 안정화되면서 고수준 모듈에서보다 저수준 모듈에서 변경이 잦음
- 고수준 모듈이 저수준 모듈을 의존하게 되면 저수준 모듈에 변경에 따라 고수준 모듈도 연쇄적으로 변경이 발생
<br/>

> 의존 역전 원칙을 통한 변경의 유연함
- 추상화를 통해 의존 역전 원칙 구현
- 고수준 모듈이 저수준 모듈의 추상화 타입을 의존함으로써 고수준 모듈의 변경없이 저수준 모듈을 유연하게 변경 가능
- 의존 역전 원칙은 리스코프 치환 원칙과 함께 개방 폐쇄 원칙을 따르는 설계를 만들어주는 기반
<br/>

> 왜 의존 역전 원칙인가?
- 저수준 모듈의 추상화인 인터페이스를 만들때, 저수준 모듈의 입장이 아닌 고수준 모듈의 입장을 고려
- 고수준 모듈이 저수준 모듈을 의존했던 상황이 역전되어 저수준 모듈이 고수준 모듈에 의존하게 되었음을 의미
<br/>

> 소스코드 의존과 런타임 의존
- 의존 역전을 통해 소스 코드 상에서 의존은 저수준 모듈에서 고수준 모듈로 역전
- 런타임에서는 고수준 모듈의 객체에서 저수준 모듈의 객체로 의존
- 의존 역전 원칙은 소스 코드 상에서의 역전이지 런타임에서의 역전이 아님
<br/>

> 의존 역전과 패키지
- 의존 역전 원칙의 타입의 소유도 역전 시킴
- 의존 역전 적용 전, 저수준 모듈의 패키지가 해당 데이터 타입을 소유
- 의존 역전을 적용하면 해당 타입은 고수준 모듈의 패키지가 소유
- 타입의 소유 역전은 각 패키지를 독립적으로 배포할 수 있도록 만들어줌




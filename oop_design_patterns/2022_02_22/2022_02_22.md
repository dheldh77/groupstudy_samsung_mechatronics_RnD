# 04 재사용 : 상속보단 조립
## 1) 상속과 재사용
- 상속은 기능을 확장할 수 있기 때문에 기능의 재사용이라는 장점이 있지만, 변경의 유연함이라는 측면에서 치명적인 단점을 가짐

### 상속을 통한 재사용의 단점 
(1) 상위 클래스 변경의 어려움
- 어떤 클래스를 상속받는 다는 것은 그 클래스를 의존하는 것.
- 의존하는 클래스의 코드가 변경되면 영향을 받을수 있음
- 상속 계층을 따라 상위 클래스의 변경이 하위 클래스에 영향을 준다.

(2) 클래스의 불필요한 증가
- 필요한 기능의 조합이 증가할수록 클래스의 개수는 함께 증가하고 구조가 복잡해진다.

(3) 상속의 오용
- 상속은 IS-A 관계가 성립할 때에만 사용해야 한다.
- 서로 다른 책임을 갖고 있는 클래스의 구현을 재사용하기 위해 상속을 받게 되면 잘못된 사용으로 인한 문제점이 발생한다.

## 2) 조립을 이용한 재사용
- 객체 조립(Composition)은 여러 객체를 묶어서 더 복잡한 기능을 제공하는 객체를 만들어 내는 것
- 객체 지향 언어에서 객체 조립은 보통 필드에서 다른 객체를 참조하는 방식으로 구현
- 한 객체가 다른 객체를 조립해서 필드로 갖는다는 것은 다른 객체의 기능을 사용한다는 의미를 내포
- 조립을 사용하면 상속을 잘못 사용해서 발생했던 문제가 제거(상위 클래스 변경의 어려움, 클래스의 불필요한 증가, 상속의 오용)
- 또한 조립은 런타임에 조립 대상 객체를 교체할 수 있음

### 상속보다는 객체 조립을 사용할 것
- 상속을 사용하다 보면 변경의 관점에서 유연함이 떨어질 가능성이 높기 때문에 객체 조립을 먼저 고민할 것
- 단, 조립의 단점은 런타임 구조가 복잡해지고 구현이 어렵다는 것

## 3) 위임(Delegation)
- 책임을 다른 객체에 넘긴다는 의미로 조립 방식을 이용해 위임을 구현
- 위임은 조립과 마찬가지로 요청을 위임할 객체를 필드로 연결
- 또는 메소드 안에서 객체를 새로 생성해서 요청을 전달해도 위임이란 의미에서 벗어나지 않음

## 4) 상속을 사용해야할 때
- 재사용이라는 관점이 아닌 기능의 확장이라는 관점에 적용
- 명확한 IS-A 관계가 성립할 때 점진적으로 상위 클래스의 기능을 확장해나가기위해 적용


# 05. 설계원칙 : SOLID
- 단일 책임 원칙 (SRP, Single responsibility principle)
- 개방-폐쇄 원칙 (OCP, Open-closed principle)
- 리스코프 치환 원칙 (LSP, Liskov substitution principle)
- 인터페이스 분리 원칙 (ISP, Interface segregation principle)
- 의존 역전 원칙 (DIP, Dependency inversion principle)

## 1) 단일 책임 원칙 (SRP, Single responsibility principle)
- "클래스는 단 하나의 책임을 가져야한다"
- 객체 지향의 기본은 책임을 객체에게 할당하는 것
- 책임마다 변경되는 이유가 발생하기 때문
- 클래스가 한 개의 이유로만 변경되려면 클래스는 한 개의 책임만을 가져야 함
- 즉, 클래스를 변경하는 이유는 단 하나여야 한다.

### 단일 책임 원칙을 위반 시 발생하는 문제점
- 하나의 기능의 변화로 연쇄적인 변화가 발생
- 재사용을 어렵게 만듬
- 여러가지 책임이 있을 경우, 하나의 책임을 재사용하기 위해 실제 필요하지 않는 책임까지 필요

### 책임이란 변화에 대한 것
- 책임의 단위는 변화되는 부분과 관련
서로 다른 이유로 바뀌는 책임들이 한 클래스에 함께 포함되어 있다면 해당 클래스는 단일 책임을 어기고 있는 것
<br/>

## 2) 개방 폐쇄 원칙 (OCP, Open-closed principle)
- "확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다"
- 즉, 기능을 변경하거나 확장할 수 있으면서 그 기능을 사용하는 코드는 수정하지 않는다는 의미
- 개방 폐쇄 원칙을 구현할 수 있는 이유는 확장되는 부분(즉, 변화되는 부분)을 '추상화'해서 표현했기 때문 -> 추상화로 구현 가능
- 개방 폐쇄 원칙을 구현하는 또 다른 방법은 상속을 이용

### 개발 폐쇄 원칙이 깨질 때의 주요 증상
- 

